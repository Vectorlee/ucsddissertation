\subsection{Malware Analysis}
Malicious software, often called malware, is always a pressing threat 
on the Internet. It has been used by attackers to steal sensitive user data, 
control victim machines to launch spam campaigns or DDoS campaigns, or 
encrypt valuable data to demand ransom, etc. Symantec has reported over 200 
Million new malware variants just in 2018 alone~\cite{symantecmalware}. 
Therefore, it is crucial for threat intelligence products to cover recent 
malware comprehensively.
Malware threat intelligence data usually comes as two forms: file hashes,
like MD5, that represent malware variants themselves, and IPs or domains
that host Command-and-Control servers for the malware. Both forms of 
data is critical for organizations, as the presence of either form 
indicates a strong possibility of compromise, and immediate actions need 
to be taken. To generate these data, security companies rely on analyzing 
unknown binaries, collected from the Internet or uploaded by customers,
to determine if they are malicious.

To identify if an unknown binary is malware, one straightforward yet
effective way is to check if the binary is a variant of known malware.
Since it is nontrivial to develop a sophisticated malware program, 
attackers tend to just modify existing malware to generate new unseen
variants. Some typical ways include code transformation (e.g. replace ``mov 
eax, 0'' with ``xor eax, eax''), obfuscation, or encrypting the original 
binary and stores the result as data in a new executable (with a packer 
program). These simple techniques enable attackers to quickly generate a 
large number of variants from a single malware instance, and significantly 
increase the overhead for security experts to analyze them.

To compare a new malware sample with existing ones, we need to define a 
suitable representation of malware samples, from which we can calculate 
the similarity between them. There are two approaches to construct this 
representation: \textit{Content-based} and \textit{Behavior-based}. 
The content-based approach abstracts a program based on its code content, and 
calculates the similarity between programs by comparing their code. 
Early work by M. Gheorghescu~\etal~\cite{Gheorghescu2006ANAV} propose 
to break the malware program into basic blocks and compare the similarity 
between those blocks.
Dullien~\etal~\cite{dullien2005graph} extract control flow graphs from 
malware programs and use graph similarity as the similarity between programs.
These content-based approaches rely on analyzing program code itself, so 
they still suffer the problem of advanced code obfuscation, which can modify
the code dramatically while maintaining the same functionality. This leads to
the behavior-
based approach, where we extract the actual behavior of malware and use that
as the signature for comparison. Lee~\etal~\cite{lee2006behavioral} propose
to use system call sequence as the signature to classify different malware
samples. Bailey~\etal~\cite{bailey2007automated} use the \textit{non-transient
state changes} malware causes on a system (files written, processes created) as 
the behavior signature, and do the comparison based on these behaviors. Holz 
~\etal~\cite{rieck2008learning} further developed this behavior-based method, 
and use the actions of malware as machine learning features, and use a 
supervised machine learning model to conduct the comparison and classification.
Bayer~\etal~\cite{bayer2009scalable} used taint tracking to capture a finer
granularity of malware's behavior, and use this information for more precise
identification. The behavior-based approaches usually capture the behavior of
malware through dynamically executing the malware samples, so it won't be 
affected by malware code itself, but executing the code for every variant in
question impose nontrivial overhead. 

When there is no existing malware to compare with, or the program in question 
does not match any known malware, an analysis system will need to decide if
the program is malicious just based on the behavior of the program itself. Like
the intrusion detection methods described in the previous section, the logic
here also relies on having ``specifications'' that cover potential malware 
behaviors, and check if the analyzed program exhibits those behaviors. One 
common heuristic is to check if the program makes any changes to the system
registry. GateKeeper~\cite{wang2004gatekeeper}, for example, detects spyware
by monitoring if the program registers as an OS auto-start extension, such as 
an NT service, a tray icon in Windows, or a Unix daemon/cron job. Other tools
also check different detection points, such as VICE~\cite{bulter2004vice}, which
checks for the existence of various hooks used by rootkits. More advanced 
systems tend to further monitor the detailed behavior of the program. For example, 
Kirda~\etal~\cite{kirda2006behavior} try to detect a popular type of
spyware that uses Internet Explorer’s Browser Helper Object (BHO) and 
toolbar interfaces to monitor a user’s browsing behavior. The system uses 
dynamic analysis to track if the program monitors users' actions and sends
out its findings to an external entity. Panorama~\cite{yin2007panorama}, 
similarly, uses dynamic taint tracking to construct the information flow of
an unknown program, and then use pre-defined policies(specifications) to 
determine if the program is malicious or not.